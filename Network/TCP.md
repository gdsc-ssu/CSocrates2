# 🌐 Study: TCP/IP Fundamentals (Deep Dive)

> [!abstract] **개요**
>     
> - **목표**: TCP/IP의 이론적 이해를 넘어 커널 수준의 동작과 실무적 성능 튜닝 개념 정립
>     
> - **핵심 키워드**
> - `#TCP_IP` `#Network_CS` `#Socket_Programming` `#Performance_Tuning`
>     

---

## Application 7 Layer 와 TCP/IP

네트워크 첫 시간에 항상 살펴보아야 하는 것이 있다. 바로 Application 7 Layer 이다.
OSI 7 layer 를 나눈 이유는 무엇일까? 
-> 흐름을 한눈에 알아보기 쉽고 7단계 중 특정한 곳에 이상이 생기면 다른 단계의 장비 및 소프트웨어를 건들이지 않고도 이상이 생긴 단계만 고칠 수 있기 때문이다. 

![[스크린샷 2026-01-25 오후 7.51.42.png]]

또한 계층별로 표준화된 프로토콜 템플릿을 통해 네트워크 프로토콜을 전부 개발하는 대신 계층별로 프로토콜을 개발해 네트워크 구성 요소들을 모듈화 할 수 있다. 모듈화된 요소는 기존에 개발된 프로토콜과 연동해 사용할 수 있다. 

애플리케이션 개발자는 애플리케이션 계층 프로토콜을 개발할 때 하위 데이터 계층(1~4) 를 고려하지 않고 데이터를 표현하는 데 초점을 맞춘다. 반대로 애플리케이션 계층은 애플리케이션 개발자들이 고려해야할 영역이므로 네트워크 엔지니어는 이 부분에 대햇 일반적으로 심각하게 고려하지 않는다. 
이런 이유로 개발자는 ==**하향식 형식**==으로 네트워크를 바라보게 되는 것이다.

## 1. TCP/IP 프로토콜 스택

현대 네트워크는 대부분 TCP/IP로 이루어져 있다. 일부 특수한 환경에서는 다른 프로토콜이 사용되기도 하지만 현대에는 몇번의 큰 기술의 발전을 거쳐 성능이 우수한 TCP/IP 를 쓰고 있다. TCP/IP 는 이론보다 실용성에 중점을 둔 프로토콜이다.

![[스크린샷 2026-01-25 오후 7.57.58.png]]
TCP/IP 모델은 상위 3개 계층을 하나의 애플리케이션 계층으로 묶고 1,2 계층, 즉 물리 계층과 데이터 링크 계층을 하나의 네트워크 계층으로 구분한다. 현시레 쉽게 반영하도록 간단히 구분하는 TCP/IP 프로토콜 스택의 성향이 이곳에서 드러난다. 


## 1. TCP/IP의 정체: 왜 묶어서 부르는가?

TCP/IP는 단순한 프로토콜이 아닌 **인터넷 프로토콜 스위트(Suite)**, 즉 통신 규약의 모음이다.

- **IP (Internet Protocol)**: 패킷 전달 여부를 보장하지 않으며 순서가 바뀔 수 있는 '비신뢰성' 패킷 통신 방식
    
- **TCP (Transmission Control Protocol)**: IP 위에서 동작하며 데이터 전달을 보장하고 순서를 유지해 주는 '신뢰성' 프로토콜
    
- **통합의 이유**: HTTP, FTP, SMTP 등 수많은 상위 애플리케이션 프로토콜이 TCP 기반 위에서 IP를 통해 동작하기 때문에 관습적으로 묶어 부른다. 

TCP/IP 는 하나의 프로토콜이 아닌 TCP와 IP를 합쳐서 부르는 말이다. TCP/IP를 사용하겠다는 것은 IP 주소 체계를 따르고 IP Routing을 이용해 목적지에 도달하며 TCP의 특성을 활용해 송신자와 수신자의 논리적 연결을 생성하고 신뢰성을 유지할 수 있도록 하겠다는 것을 의미한다. 

![[스크린샷 2026-01-25 오후 8.00.41.png]]

---
## 2. TCP 신뢰성 보장 전략

3.1 연결 수립 (3-way Handshake)
데이터 전송 전, 양방향 통신이 가능한지 확인하는 과정이다. 

![[Pasted image 20260125163635.png]]

1. **SYN (Synchronize)**: 송신자가 수신자에게 통신 가능 여부를 확인한다. (Port 오픈 필수).
2. **SYN/ACK**: 수신자가 준비되었음을 알리고 응답한다.
3. **ACK (Acknowledge)**: 송신자가 최종 응답을 보내며 전송을 시작한다.

3.2 흐름 제어 (Flow Control)

송신자는 수신자가 받을 수 있는 만큼 데이터를 전송한다. 수신자가 자신이 받을 수 있는 바이트 수 (사용하지 않은 버퍼 크기, receive window)를 송신자에게 전달한다. 송신자는 수신자 receive window가 허용하는 바이트 수만큼 데이터를 전송한다. 

- **Window Size**: 수신자가 한 번에 받을 수 있는 데이터 양을 송신자에게 알린다.
	- Window Size 보다 보낼 데이터의 양이 크게 되면 송신자는 wait 하게 된다. 
- **Ack Number**: 수신자가 "N번까지 잘 받았으니 N+1번을 달라"고 요청하며 속도를 조절한다.

3.3 혼잡 제어 (Congestion Control)

- 네트워크 정체를 방지하기 위해 receive window와 별도로 congestion window를 사용하는데 이는 네트워크에 유입되는 데이터양을 제한하기 위해서이다. 
- Receieve window와 마찬가지로 congestion window 가 허용되는 바이트 수만큼 데이터를 전송하며 여기에는 TCP Vegas, Westwood 등 다양한 알고리즘이 있다.
- Flow Control과 달리 송신자가 단독으로 구현한다. 


> [!tip] **HTTPS와의 관계** HTTPS는 TCP 기반이므로, SSL/TLS Handshake를 수행하기 전에 반드시 TCP 3-way Handshake가 먼저 완료되어야 합니다.


![[스크린샷 2026-01-25 오후 5.35.38.png]]

위 이미지는 TCP 기반의 프로토콜인 HTTPS의 SSL handshake를 나타낸 것이다. 
- 파란색 : TCP 의 3-way handshake
- 노란색 : HTTPS 의 SSL handshake


## 3. TCP/IP 4 계층 동작 순서
![[스크린샷 2026-01-25 오후 8.05.02.png]]
1. 송신측 클라이언트의 애플리케이션 계층에서 어느 웹 페이지늘 보고 싶다라는 HTTP 요청을 지시한다. 
2. 그 다음에 있는 전송 계층에서는 애플리케이션 계층에서 받은 데이터(HTTP 메시지)를 통신하기 쉽게 조각내어 안내 번호와 포트 번호(TCP 패킷)를 붙여 네트워크 계층에 전달한다. 
3. 네트워크 계층에서 데이터에 IP 패킷을 추가해서 링크 계층에 전달한다. 
4. 링크 계층에서는 수신지 MAC 주소와 이더넷 프레임을 추가한다. 
5. 이로써 네트워크를 통해 송신할 준비가 되었다. 
6. 수신측 서버는 링크 계층에서 데이터를 받아들여 순서대로 위의 계층에 전달하여 애플리케이션 계층까지 도달한다. 
7. 수신측 애플리케이션 계층에 도달하게 되면 클라이언트가 발신했던 HTTP 리퀘스트를 수신할 수 있다.


---
# 운영체제와 TCP/IP 수신

이제 Linux 운영체제와 하드웨어 레이어에서의 데이터 흐름과 제어 흐름을 바탕으로 네트워크 스택에 대한 전반적인 작동 방식을 알아보자 

## 2.1 데이터 전송

네트워크 스택에는 여러 레이어가 있다. 

여러 레이어가 있지만, 크게 유저(user) 영역, 커널(kernel) 영역, 디바이스(device) 영역으로 나눌 수 있다. 유저 영역과 커널 영역에서의 작업은 CPU가 수행한다. 
이 유저 영역과 커널 영역은 디바이스 영역과 구별하기 위해 host라고 부른다. 여기서 디바이스는 패킷을 송수신하는 NIC(Network Interface Card) 이다. 흔히 부르는 랜카드보다 더 정확한 용어이다.

![[Pasted image 20260125205451.png]]
유저 영역 밑으로 내려가 보자. 우선 애플리케이션이 전송할 데이터를 생성하고 , wirte 시스템 콜을 호출해서 데이터를 보낸다. 소켓(fd)는 이미 생성되어 연결되어 있다고 가정한다. 시스템 콜을 호출하면 커널 영역으로 전환된다. 

Linux나 Unix를 포함한 POSIX 계열 운영체제는 소켓을 file descriptor로 애플리케이션에 노출한다. 이런 POSIX 계열의 운영체제에서 소켓은 파일의 한 종류이다. 파일 레이어는 단순한 검사만 하고 구조체에 연결된 소켓 구조체를 사용해서 소켓 함수를 호출한다. 

![[Pasted image 20260125212200.png]]
> 어차피, 파일을 사용하는 거면 write()를 쓰면 되지 않을까? 

물론 가능하지만 소켓도 통신 규약이 있으며 정보를 제어하기 위해서는 send(), recv() 같은 함수를 쓰는 것을 권장하는 것이다.


커널 소켓은 두 개의 버퍼를 가지고 있다. 송신용으로 준비한 send socket buffer, 수신용으로 준비한 receive socket buffer이다. write 시스템 콜을 호출하면 유저 영역의 데이터가 커널 메모리로 복사되고, send socket buffer 뒷부분에 추가가 된다. 

소켓과 연결된 TCP Control Block(TCB) 구조체가 있다. TCB에는 TCP 연결 처리에 필요한 정보가 있다. TCB에 있는 데이터는 connection state(LISTEN, ESTABLISHED, TIME_WAIT 등), receive window, congestion window, sequence 번호, 재전송 타이머 등이다.

현재 TCP 상태가 데이터 전송을 허용하면 새로운 TCP segment, 즉 패킷을 생성한다. Flow control 같은 이유로 데이터 전송이 불가능하면 시스템 콜은 여기서 끝나고, 유저 모드로 돌아간다(즉, 애플리케이션으로 제어권이 넘어간다).

TCP segment에는 TCP 헤더와 페이로드(payload)가 있다. 페이로드에는 ACK를 받지 않은 send socket buffer에 있는 데이터가 담겨 있다. 페이로드의 최대 길이는 receive window, congestion window, MSS(Maximum Segment Size) 중 최대 값이다.

그리고 TCP checksum을 계산한다. 이 checksum 계산에는 pseudo 헤더 정보(IP 주소들, segment 길이, 프로토콜 번호)를 포함시킨다. 여기서 TCP 상태에 따라 패킷을 한 개 이상 전송할 수 있다.

사실 요즘의 네트워크 스택에서는 checksum offload 기술을 사용하기 때문에, 커널이 직접 TCP checksum을 계산하지 않고 대신 NIC가 checksum을 계산한다. 여기서는 설명의 편의를 위해 커널이 checksum을 계산한다고 가정한다.

![[Pasted image 20260125221052.png]]

생성된 TCP segment는 IP 레이어로 이동한다(내려 간다). IP 레이어에서는 TCP segment에 IP 헤더를 추가하고, IP routing을 한다. IP routing이란 목적지 IP 주소(destination IP)로 가기 위한 다음 장비의 IP 주소(next hop IP)를 찾는 과정을 말한다.

IP 레이어에서 IP 헤더 checksum을 계산하여 덧붙인 후, Ethernet 레이어로 데이터를 보낸다.

Ethernet 레이어는 ARP(Address Resolution Protocol)를 사용해서 next hop IP의 MAC 주소를 찾는다. 그리고 Ethernet 헤더를 패킷에 추가한다. Ethernet 헤더까지 붙으면 호스트의 패킷은 완성이다.

IP routing을 하면 그 결과물로 next hop IP와 해당 IP로 패킷 전송할 때 사용하는 인터페이스(transmit interface, 혹은 NIC)를 알게 된다. 따라서 transmit NIC의 드라이버를 호출한다.

만약 [tcpdump](http://www.tcpdump.org/)나 [Wireshark](http://www.wireshark.org/) 같은 패킷 캡처 프로그램이 작동 중이면 커널은 패킷 데이터를 프로그램이 사용하는 메모리 버퍼에 복사한다. 수신도 마찬가지로 드라이버 바로 위에서 패킷을 캡처한다. 대개 traffic shaper 기능도 이 레이어에서 동작하도록 구현되어있다.

드라이버는 NIC 제조사가 정의한 드라이버-NIC 통신 규약에 따라 패킷 전송을 요청한다.

NIC는 패킷 전송 요청을 받고, 메인 메모리에 있는 패킷을 자신의 메모리로 복사하고, 네트워크 선으로 전송한다. 이때 Ethernet 표준에 따라 IFG(Inter-Frame Gap), preamble, 그리고 CRC를 패킷에 추가한다. IFG, preamble은 패킷의 시작을 판단하기 위해 사용하고(네트워킹 용어로는 framing), CRC는 데이터 보호를 위해 사용한다(TCP, IP checksum과 같은 용도이다). 패킷 전송은 Ethernet의 물리적 속도, 그리고 Ethernet flow control에 따라 전송할 수 있는 상황일 때 시작된다. 회의장에서 발언권을 얻고 말하는 것과 비슷하다.

NIC가 패킷을 전송할 때 NIC는 호스트 CPU에 인터럽트(interrupt)를 발생시킨다. 모든 인터럽트에는 인터럽트 번호가 있으며, 운영체제는 이 번호를 이용하여 이 인터럽트를 처리할 수 있는 적합한 드라이버를 찾는다. 드라이버는 인터럽트를 처리할 수 있는 함수(인터럽트 핸들러)를 드라이브가 가동되었을 때 운영체제에 등록해둔다. 운영체제가 핸들러를 호출하고, 핸들러는 전송된 패킷을 운영체제에 반환한다.

지금까지 설명한 것은 애플리케이션에서 쓰기를 하였을 때 데이터가 커널과 디바이스를 거쳐 전송되는 과정이다. 그런데 애플리케이션이 쓰기 요청을 직접적으로 하지 않아도 커널이 TCP를 호출해서 패킷을 전송하는 경우가 있다. 예를 들어 ACK을 받아 receive window가 늘어나면 socket buffer에 남아있는 데이터를 포함한 TCP segment를 생성하여 상대편에 전송한다.



# 데이터 수신 

![[Pasted image 20260125230459.png]]

우선 NIC가 패킷을 자신의 메모리에 기록한다. CRC 검사로 패킷이 올바른지 검사하고, 호스트의 메모리버퍼로 전송한다. 이 버퍼는 드라이버가 커널에 요청하여 패킷 수신용으로 미리 할당한 메모리이고, 할당을 받은 후 드라이버는 NIC에 메모리 주소와 크기를 알려 준다. NIC가 패킷을 받았는데, 드라이버가 미리 할당해 놓은 호스트 메모리 버퍼가 없으면 NIC가 패킷을 버릴 수 있다 (packet drop).

패킷을 호스트 메모리로 전송한 후, NIC가 호스트운영체제에 인터럽트를 보낸다.

드라이버가 새로운 패킷을 보고 자신이 처리할 수 있는 패킷인지 검사한다. 여기까지는 제조사가 정의한 드라이버-NIC 통신 규약을 사용한다.

드라이버가 상위 레이어로 패킷을 전달하려면 운영체제가 이해할 수 있도록, 받은 패킷을 운영체제가 사용하는 패킷 구조체로 포장해야 한다. 예를 들어, Linux의 sk_buff, BSD 계열 커널의 mbuf, 그리고 Microsoft Windows의 NET_BUFFER_LIST가 운영체제의 패킷 구조체이다. 드라이버는 이렇게 포장한 패킷을 상위 레이어로 전달한다.

Ethernet 레이어에서도 패킷이 올바른지 검사하고, 상위 프로토콜(네트워크 프로토콜)을 찾는다(de-multiplex). 이때 Ethernet 헤더의 ethertype 값을 사용한다. IPv4 ethertype은 0x0800이다. Ethernet 헤더를 제거하고 IP 레이어로 패킷을 전달한다.

IP 레이어에서도 패킷이 올바른지 검사한다. IP 헤더 checksum을 확인하는 것이다. 논리적으로 여기서 IP routing을 해서 패킷을 로컬 장비가 처리해야 하는지, 아니면 다른 장비로 전달해야 하는지 판단한다. 로컬 장비가 처리해야 하는 패킷이면 IP 헤더의 proto 값을 보고 상위 프로토콜(트랜스포트 프로토콜)을 찾는다. TCP proto 값은 6이다. IP 헤더를 제거하고 TCP 레이어로 패킷을 전달한다.

하위 레이어에서와 마찬가지로 TCP 레이어에서도 패킷이 올바른지 검사한다. TCP checksum도 확인한다. 앞서 언급했듯이 요즘의 네트워크 스택에는 checksum offload 기술이 적용되어 있기 때문에 커널이 checksum을 직접 계산하지 않는다.

다음으로 패킷이 속하는 연결, 즉 TCP control block을 찾는다. 이때 패킷의 <소스 IP, 소스 port, 타깃 IP, 타깃 port>를 식별자로 사용한다. 연결을 찾으면 프로토콜을 수행해서 받은 패킷을 처리한다. 새로운 데이터를 받았다면, 데이터를 receive socket buffer에 추가한다. TCP 상태에 따라 새로운 TCP 패킷(예를 들어 ACK 패킷)을 전송할 수 있다. 여기까지 해서 TCP/IP 수신 패킷 처리 과정이 끝나게 된다.

Receive socket buffer 크기가 결국은 TCP의 receive window이다. 어느 지점까지는 receive window가 크면 TCP throughput이 증가한다. 예전에는 socket buffer 크기를 애플리케이션이나 운영체제 설정에서 조절하고는 했다. 최신 네트워크 스택은 receive socket buffer 크기, 즉 receive window를 자동으로 조절하는 기능을 가지고 있다.

이후 애플리케이션이 read 시스템 콜을 호출하면 커널 영역으로 전환되고, socket buffer에 있는 데이터를 유저 공간의 메모리로 복사해 간다. 복사한 데이터는 socket buffer에서 제거한다. 그리고 TCP를 호출한다. TCP는 socket buffer에 새로운 공간이 생겼기 때문에 receive window를 증가시킨다. 그리고 프로토콜 상태에 따라 패킷을 전송한다. 패킷 전송이 없으면 시스템 콜이 종료된다.

